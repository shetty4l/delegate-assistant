import { mkdir, writeFile } from "node:fs/promises";
import { dirname, join, resolve } from "node:path";

import type { PublishPrInput, PublishPrResult } from "@delegate/domain";
import type { VcsPort } from "@delegate/ports";

type GitHubAdapterOptions = {
  repoPath: string;
  baseBranch?: string;
};

type RunResult = {
  exitCode: number;
  stdout: string;
  stderr: string;
};

const assertRepoRelativePath = (
  repoPath: string,
  relativePath: string,
): string => {
  const trimmed = relativePath.trim();
  if (trimmed.length === 0) {
    throw new Error("Artifact path must not be empty");
  }
  if (
    trimmed.startsWith("/") ||
    trimmed.startsWith("~") ||
    trimmed.includes("\\")
  ) {
    throw new Error("Artifact path must be repo-relative");
  }
  if (trimmed.split("/").some((segment) => segment === "..")) {
    throw new Error("Artifact path cannot escape repository root");
  }

  const target = resolve(join(repoPath, trimmed));
  const root = resolve(repoPath);
  if (!target.startsWith(`${root}/`) && target !== root) {
    throw new Error("Artifact path resolves outside repository root");
  }

  return target;
};

export class LocalGitHubVcsAdapter implements VcsPort {
  private readonly repoPath: string;
  private readonly configuredBaseBranch: string | null;

  constructor(options: GitHubAdapterOptions) {
    this.repoPath = options.repoPath;
    this.configuredBaseBranch = options.baseBranch ?? null;
  }

  async publishPr(input: PublishPrInput): Promise<PublishPrResult> {
    const originalBranch = await this.currentBranch();
    const baseBranch = this.configuredBaseBranch ?? originalBranch;
    const branchName = `assistant/work-item-${input.workItemId.slice(0, 8)}`;
    const title = `assistant: ${input.summary.slice(0, 72)}`;
    const body = [
      "## Summary",
      `- Work item: ${input.workItemId}`,
      `- Generated artifact: ${input.artifact.path}`,
      "",
      "Generated by Delegate Assistant.",
    ].join("\n");

    let switchedToBase = false;

    try {
      if (originalBranch !== baseBranch) {
        await this.runOrThrow(
          ["git", "checkout", baseBranch],
          "checkout base branch",
        );
        switchedToBase = true;
      }

      await this.checkoutOrCreateBranch(branchName);

      const absolutePath = assertRepoRelativePath(
        this.repoPath,
        input.artifact.path,
      );
      await mkdir(dirname(absolutePath), { recursive: true });
      await writeFile(absolutePath, input.artifact.content, "utf8");

      await this.runOrThrow(
        ["git", "add", input.artifact.path],
        "stage generated artifact",
      );

      const hasStagedChanges = await this.hasStagedChanges();
      if (hasStagedChanges) {
        await this.runOrThrow(
          ["git", "commit", "-m", title],
          "commit generated artifact",
        );
      }

      await this.runOrThrow(
        ["git", "push", "-u", "origin", branchName],
        "push assistant branch",
      );

      const existingPrUrl = await this.findExistingPrUrl(branchName);
      const pullRequestUrl =
        existingPrUrl ??
        (await this.createPullRequest({
          baseBranch,
          branchName,
          title,
          body,
        }));

      return {
        branchName,
        pullRequestUrl,
      };
    } finally {
      const target = switchedToBase ? originalBranch : baseBranch;
      await this.run(["git", "checkout", target]);
    }
  }

  private async currentBranch(): Promise<string> {
    const result = await this.runOrThrow(
      ["git", "rev-parse", "--abbrev-ref", "HEAD"],
      "read current branch",
    );
    return result.stdout.trim();
  }

  private extractPrUrl(stdout: string): string {
    const line = stdout
      .split("\n")
      .map((entry) => entry.trim())
      .find((entry) => entry.startsWith("https://"));
    if (!line) {
      throw new Error(
        `Unable to parse PR URL from gh output: ${stdout.trim()}`,
      );
    }
    return line;
  }

  private async checkoutOrCreateBranch(branchName: string): Promise<void> {
    const existing = await this.run([
      "git",
      "rev-parse",
      "--verify",
      branchName,
    ]);
    if (existing.exitCode === 0) {
      await this.runOrThrow(["git", "checkout", branchName], "checkout branch");
      return;
    }

    await this.runOrThrow(
      ["git", "checkout", "-b", branchName],
      "create branch",
    );
  }

  private async hasStagedChanges(): Promise<boolean> {
    const result = await this.run(["git", "diff", "--cached", "--quiet"]);
    return result.exitCode === 1;
  }

  private async createPullRequest(input: {
    baseBranch: string;
    branchName: string;
    title: string;
    body: string;
  }): Promise<string> {
    const prCreate = await this.runOrThrow(
      [
        "gh",
        "pr",
        "create",
        "--base",
        input.baseBranch,
        "--head",
        input.branchName,
        "--title",
        input.title,
        "--body",
        input.body,
      ],
      "create pull request",
    );
    return this.extractPrUrl(prCreate.stdout);
  }

  private async findExistingPrUrl(branchName: string): Promise<string | null> {
    const result = await this.run([
      "gh",
      "pr",
      "list",
      "--head",
      branchName,
      "--json",
      "url",
      "--limit",
      "1",
    ]);

    if (result.exitCode !== 0) {
      return null;
    }

    try {
      const parsed = JSON.parse(result.stdout) as Array<{ url?: string }>;
      const url = parsed[0]?.url;
      return typeof url === "string" && url.length > 0 ? url : null;
    } catch {
      return null;
    }
  }

  private async runOrThrow(cmd: string[], step: string): Promise<RunResult> {
    const result = await this.run(cmd);
    if (result.exitCode !== 0) {
      const details =
        result.stderr.trim() || result.stdout.trim() || "no output";
      throw new Error(`${step} failed (exit=${result.exitCode}): ${details}`);
    }
    return result;
  }

  private async run(cmd: string[]): Promise<RunResult> {
    const proc = Bun.spawn({
      cmd,
      cwd: this.repoPath,
      stdout: "pipe",
      stderr: "pipe",
    });

    const [stdout, stderr, exitCode] = await Promise.all([
      new Response(proc.stdout).text(),
      new Response(proc.stderr).text(),
      proc.exited,
    ]);

    return {
      exitCode,
      stdout,
      stderr,
    };
  }
}
